{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-12-16T02:02:59.813969+00:00",
  "repo": "tls-attestation/use-cases-and-properties",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "Interim",
      "description": "",
      "color": "07e9ce"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOP_9tTM7T0Smo",
      "title": "Add GitHub repo link in draft",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/3",
      "state": "OPEN",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add GitHub repo link in draft for easy issue filing ",
      "createdAt": "2025-10-26T10:06:41Z",
      "updatedAt": "2025-10-26T10:06:41Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOP_9tTM7T1aV0",
      "title": "Confidential Data Collaboration, specifically SMPC",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/4",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is not an ideal use case (certainly should not appear as the first one) because SMPC, when deployed correctly, should not be vulnerable to active attackers, i.e. it should provide \"malicious security\" and not just \"semi honest security\".\n\n",
      "createdAt": "2025-10-26T13:58:50Z",
      "updatedAt": "2025-11-30T16:11:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is not an ideal use case (certainly should not appear as the first one) \n\nWould reversing the order of first two use cases address this? \n\n> SMPC, when deployed correctly, should not be vulnerable to active attackers, i.e. it should provide \"malicious security\" and not just \"semi honest security\".\n\nCould you explain? The protocol is indeed being designed to protect against active attackers. I don't see why this is particularly a problem with SMPC.",
          "createdAt": "2025-11-30T15:04:14Z",
          "updatedAt": "2025-11-30T15:04:14Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "> > This is not an ideal use case (certainly should not appear as the first one)\n> \n> Would reversing the order of first two use cases address this?\n> \n\nYes.\n\n> > SMPC, when deployed correctly, should not be vulnerable to active attackers, i.e. it should provide \"malicious security\" and not just \"semi honest security\".\n> \n> Could you explain? The protocol is indeed being designed to protect against active attackers. I don't see why this is particularly a problem with SMPC.\n\nSMPC is hard to implement, and there's usually no motivation to add the complexity of attestation on top of that, because you're getting the desired security guarantees from the cryptography.",
          "createdAt": "2025-11-30T15:24:33Z",
          "updatedAt": "2025-11-30T15:24:33Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree with reordering. Single party should be before multi-party. Done in my local copy.\n\n> SMPC is hard to implement, and there's usually no motivation to add the complexity of attestation on top of that, because you're getting the desired security guarantees from the cryptography.\n\nI think there is confusion here between SPMC used in cryptography vs. multiple parties communicating securely (MPC). We intended to mean the latter.",
          "createdAt": "2025-11-30T16:11:02Z",
          "updatedAt": "2025-11-30T16:11:02Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOP_9tTM7T1aWR",
      "title": "High-Assurance Command Execution",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/5",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The requirement is questionnable, because a malicious execution environment does not need a command to do its harm. It is actually the _operator_ that needs to be attested in this use case.\n\nA similar consideration applies to \"Securing Control and Management Planes\" where again, the vulnerable point is the administrator. In that case, we mention stealing credentials as a risk, but it is significantly easier to address credential stealing (e.g. by using PAKE) than with attestation infrastructure.\n\n",
      "createdAt": "2025-10-26T13:58:52Z",
      "updatedAt": "2025-10-26T13:58:52Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOP_9tTM7T1aWv",
      "title": "Use Cases vs. Properties",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/6",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A general problem with this draft is that there is no connection between Sec. 3 and Sec. 4, to a level where they could each be a separate draft.\n\n",
      "createdAt": "2025-10-26T13:58:53Z",
      "updatedAt": "2025-12-01T13:07:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, I believe properties are much more useful than high-level use cases.",
          "createdAt": "2025-11-30T15:07:47Z",
          "updatedAt": "2025-11-30T15:07:47Z"
        },
        {
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I believe properties are much more useful than high-level use cases.\n\nFunnily enough, the charter only asks for a use-cases document.\n\nAgree that there's no explicit connection between the two - the only logical connection is that both use-cases and properties are meant to be generic over the solutions produced by the WG.",
          "createdAt": "2025-12-01T10:49:17Z",
          "updatedAt": "2025-12-01T10:49:17Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "From a reader's perspective, it is strange to read a document where properties are disconnected from use cases. \n\nAlso, when you tie properties to use cases it provides some level of validation of the properties.",
          "createdAt": "2025-12-01T11:46:41Z",
          "updatedAt": "2025-12-01T11:46:41Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Funnily enough, the charter only asks for a use-cases document.\n\nBut in AD's interpretation, I don't think it actually means just \"use cases\" per se. \n\n> From a reader's perspective, it is strange to read a document where properties are disconnected from use cases.\n\nAgree, we will add that glue.",
          "createdAt": "2025-12-01T13:07:03Z",
          "updatedAt": "2025-12-01T13:07:03Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOP_9tTM7T1aXI",
      "title": "Valid but Old",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/7",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> attacks where an attacker presents valid, but old or unrelated Evidence from a different connection or context\n\nI suggest dropping \"old\" because age of the Evidence is a criterion when evaluation it for validity.\n\n",
      "createdAt": "2025-10-26T13:58:55Z",
      "updatedAt": "2025-11-30T16:03:50Z",
      "closedAt": "2025-11-30T16:03:50Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Are you proposing this?\n> attacks where an attacker presents valid Evidence from a different connection or context",
          "createdAt": "2025-11-30T15:11:27Z",
          "updatedAt": "2025-11-30T15:11:27Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "Yes, but on second read I'm also OK with the original text, because timing information in the Evidence is often not trustworthy (no secure time provisioning).",
          "createdAt": "2025-11-30T15:15:18Z",
          "updatedAt": "2025-11-30T15:15:18Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, clocks in TEEs are untrustworthy. \nClosing this issue. ",
          "createdAt": "2025-11-30T16:03:50Z",
          "updatedAt": "2025-11-30T16:03:50Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOP_9tTM7T1aXb",
      "title": "Binding to Machine Identifier",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/8",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Interim"
      ],
      "body": "References to slides are frowned upon. Also, this is importnat enough to justify a few paragraphs of text here.\n\nIn addition, the short sentence here makes a ton of assumptions on the deployment model (e.g. \"infrastructure provider\") that require clarification.\n\n",
      "createdAt": "2025-10-26T13:58:56Z",
      "updatedAt": "2025-12-15T08:58:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> References to slides are frowned upon.\n\nUnfortunately, we could not manage to complete the pre-print for the formal analysis work until the cutoff. The link will be replaced by that in the future.",
          "createdAt": "2025-10-27T20:24:15Z",
          "updatedAt": "2025-10-27T20:24:15Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOP_9tTM7T1aXu",
      "title": "Attestation Credential Freshness",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/9",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "RFC 9334 discusses freshness as related to periods of time. This section takes a rather extreme position that the Evidence needs to be bound to the specific connection. This may be very challenging in real life cases, e.g. many short-lived connections, or even many connections spawned in parallel. The requirement may be right for attested TLS, but needs a strong justification.\n\n",
      "createdAt": "2025-10-26T13:58:58Z",
      "updatedAt": "2025-10-28T12:50:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The pre-print (to be finalized this week) provides the formal reasoning behind this. We can add a reference to that. ",
          "createdAt": "2025-10-27T20:29:49Z",
          "updatedAt": "2025-10-27T20:29:49Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "I am sure the formal reasoning can be summarized into an explanation for readers of the draft.",
          "createdAt": "2025-10-28T12:50:25Z",
          "updatedAt": "2025-10-28T12:50:25Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOP_9tTM7T1aX9",
      "title": "Negotiation and Capability Discovery: Fallback",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/10",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In TLS, \"graceful fallback\" is the root of all evil. I suggest to drop it from the requirement or at least to clarify where fallback is acceptable and does not result in huge security issues.\n\n",
      "createdAt": "2025-10-26T13:58:59Z",
      "updatedAt": "2025-11-30T16:04:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Do you have a pointer to one concrete security issue?",
          "createdAt": "2025-10-27T20:36:43Z",
          "updatedAt": "2025-10-27T20:36:43Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "https://www.rfc-editor.org/rfc/rfc7457.html#section-2.12 is one (old) example.\n\nMore recent:\n\nMechanism | Layer | RFC | Purpose | Mitigates\n-- | -- | -- | -- | --\nTLS_FALLBACK_SCSV | TLS 1.2 | RFC 7507 | Prevent fallback retries to lower TLS versions | Forced version downgrade\nTLS 1.3 version negotiation | TLS 1.3 | RFC 8446 | Remove need for fallback | Version negotiation confusion\nDowngrade Sentinel | TLS 1.3 | RFC 8446 \u00a74.1.3 | Cryptographic downgrade detection | Downgrade from 1.3 to \u22641.2\nStrict Version Policy | Config | N/A | Operational enforcement | Legacy protocol fallback\nHSTS | HTTP | RFC 6797 | Force HTTPS-only access | HTTPS\u2192HTTP downgrade\n",
          "createdAt": "2025-10-28T12:57:26Z",
          "updatedAt": "2025-10-28T12:57:26Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> More recent:\n\nCould you share the source of this table?",
          "createdAt": "2025-10-28T14:33:44Z",
          "updatedAt": "2025-10-28T14:33:44Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "ChatGPT :-)",
          "createdAt": "2025-10-28T14:52:40Z",
          "updatedAt": "2025-10-28T14:52:40Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "ChatGPT often hallucinates :) and maybe this is the case here. I think graceful fallback here is referring to standard TLS 1.3. ",
          "createdAt": "2025-11-30T15:27:58Z",
          "updatedAt": "2025-11-30T15:27:58Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "Of course this refers to standard TLS 1.3. And such fallback is probably unacceptable in 99% of the use cases of attestation. IMHO the security impact of fallback from attested to non-attested TLS is much more severe than from TLS 1.3 to 1.2.",
          "createdAt": "2025-11-30T16:04:46Z",
          "updatedAt": "2025-11-30T16:04:46Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOP_9tTM7T1aYa",
      "title": "Negotiation and Capability Discovery: Formats",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/11",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The \"conceptual wrappers\" are aimed at reducing the need for peers to understand RATS formats. This section should mention this fact, and perhaps the solution should allow for format negotiation that remains opaque to the endpoints.\n\n",
      "createdAt": "2025-10-26T13:59:01Z",
      "updatedAt": "2025-11-30T16:06:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Preference here is not to define concrete solutions like CMW in this doc. ",
          "createdAt": "2025-11-30T15:30:01Z",
          "updatedAt": "2025-11-30T15:30:01Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "I agree, and this wasn't my point.",
          "createdAt": "2025-11-30T16:06:20Z",
          "updatedAt": "2025-11-30T16:06:20Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOP_9tTM7T1aYw",
      "title": "Privacy Preservation",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/12",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The solution does not degrade the privacy -> The solution must not degrade the privacy (this is a requirement).\n\nAlso I suggest to to cite the [IAB Statement](https://datatracker.ietf.org/doc/statement-iab-statement-on-the-risks-of-attestation-of-software-and-hardware-on-the-open-internet/) in this section, it is not precisey about privacy but it is closely related.\n\n",
      "createdAt": "2025-10-26T13:59:02Z",
      "updatedAt": "2025-10-26T13:59:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOP_9tTM7T1adh",
      "title": "Security Considerations",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/13",
      "state": "OPEN",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This section is confusing since it overlaps significantly with the requirements. I suggest to fold its text into the requirements section and use the stanard boilerplate: \"This whole document is about security.\"\n\n",
      "createdAt": "2025-10-26T13:59:04Z",
      "updatedAt": "2025-10-26T13:59:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOP_9tTM7XmQEt",
      "title": "How do we do secure channel to RA binding?",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/14",
      "state": "OPEN",
      "author": "ionut-arm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Interim"
      ],
      "body": "This issue comes up a lot, including during the presentation at IETF-124 and on the mailing list. I'll define in words for now what we mean by cryptographic binding, why we think we need it, how it can be achieved.\n\n## Summary\n\nCryptographic binding between a secure channel (establishment) session and a remote attestation session gives the attester's peer (calling them relying party or RP henceforth) confidence that the secure channel endpoint is the attester. So if the attester has a WebPKI-based identifier, the RP can also trust that the attestation credential (AC) is representative of the entity who owns that identifier.\n\n**Attacker model**: The strongest attacker I can think of is a service provider who wants to pretend that their service resides in a TEE (or another attested environment). They have access to webPKI certs and the associated key material. They can also control the routing of traffic to this service, and can spin up the workloads they want to impersonate in attestable environments. Their only difficulty is in convincing the RP that the AC and the CertificateVerify are coming from the same endpoint.\n\n## Why?\n\nStrong binding is needed to prevent a malicious \"attester\" from just conveying an AC taken from a legitimate TEE as its own - in other words, to prevent a Man in the Middle. Without some sort of binding, the provenance of the AC can't be established, and so the RP should not trust its contents. For example, relying strictly on nonces for this would not be sufficient, since the nonces can just be forwarded to/from separate sessions.\n\n## How?\n\nThis is the crux of the problem and I'm not sure whether we should describe any specific mechanism in this draft, but instead leave it to protocol designers to ensure MitM is not possible.\n\nNevertheless, here are some examples of how to achieve this in the context of TLS in particular:\n\n* Export some keying material from the TLS session and include it in the AC. The RP can verify this binding to confirm the provenance. **Pro**: strong guarantee. **Con**: more complex to implement (?), perhaps going as far as making changes to key schedule.\n* Bind the AC to the attester's webPKI cert (e.g., by hashing the cert, or the public key...). The RP can verify that the AC was issued for an entity who owns that cert, which CertificateVerify proves is the peer. **Pro**: simpler to implement and does not involve invasive changes to secure channel protocol. **Con**: this only works if the webPKI-certified key has never left the TEE / attester; if it was provisioned at runtime, the guarantee vanishes (since the key owner could just use the same webPKI credential from an insecure context).\n* Bind the webPKI cert to the (unique) attesting platform. The RP can verify that the platform identifier from the webPKI cert corresponds to whatever is in the AC. **Pro**: similar to above. **Con**: Similar to above, plus it's only possible if the attester has a unique identity.\n\nMaybe these last two options also point to a tiered approach: you can either do direct binding to session, or binding through webPKI cert AND a new property that the certified key has never left / cannot leave the attester.\n\n## Questions for WG\n\n* At what level of detail do we describe it in the draft?\n    * Does it limit the scope of the charter if we go with a lower-level wording?\n* Do we need to perhaps phrase it as a negative property instead? e.g. \"Protocol is not subject to MitM of AC\"",
      "createdAt": "2025-11-12T15:47:39Z",
      "updatedAt": "2025-12-15T08:58:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "body": "In our draft, the attestation evidence or attestation results are carried inside the Certificate message. The CertificateVerify signature also covers the Handshake Context defined in RFC 9261, which is derived from exporter-secret\u2013based values taken from the TLS session. This means the signature is bound both to the webPKI certificate and to the TLS session in which the authenticator is generated. Only the entity that holds the private key corresponding to the webPKI certificate and that has access to the exporter-secret of the session can produce a valid CertificateVerify.\n\nHowever, the binding described above does not by itself prevent a server from obtaining attestation evidence from a different TEE and presenting it as its own. A malicious server that legitimately holds the webPKI  certificate private key and controls the TLS session can export the session-specific exporter values and forward them to a remote TEE, which can in turn produce attestation evidence that verifies correctly inside the Certificate message. To ensure that the attestation evidence originates from the same environment that holds the certificate private key, the attestation evidence will have to include the public key of the webPKI certificate used in the Certificate message, together with claims that the corresponding private key is generated and protected within the TEE. ",
          "createdAt": "2025-11-14T13:39:44Z",
          "updatedAt": "2025-11-14T13:39:44Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is TLS to RA crypto binding needed?\n\nYes, as the formal analysis has shown, it is critical to avoid relay attacks. That's why it was explicitly stated in the [charter](https://datatracker.ietf.org/wg/seat/about/): \n\n> A Standards Track document defining an attested (D)TLS protocol extension supporting remote peer and mutual attestation **bound** to the (D)TLS connection.\n\n> This effort will be restricted to leveraging the (D)TLS 1.3 protocol\nand an attestation **binding** to a (D)TLS 1.3 connection. \n\n> The attested D(TLS) protocol extension will also describe a minimum\nsubset of properties that the attested state must convey in order\nto **bind** the Evidence and Attestation Results to the TLS connection.",
          "createdAt": "2025-11-17T22:12:41Z",
          "updatedAt": "2025-11-17T22:12:41Z"
        },
        {
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tireddy2 :\n\n> A malicious server that legitimately holds the webPKI certificate private key and controls the TLS session can export the session-specific exporter values and forward them to a remote TEE, which can in turn produce attestation evidence that verifies correctly inside the Certificate message.\n\nI don't think that's feasible, because attestation evidence coming from that TEE would show that it accepts the exporter on some interface and just uses that to produce attestation evidence. Instead, the TEE measurements should point to a TLS stack that generates evidence for its own use _only_ through internal means. Basically, the measurements should _never_ get accepted if the TEE can just receive the exporter from some other machine, and just includes that in its attestation evidence. Perhaps this is another property that we need to make explicit.\n\n> the attestation evidence will have to include the public key of the webPKI certificate used in the Certificate message, together with claims that the corresponding private key is generated and protected within the TEE.\n\nI think if the property above holds (evidence contains an exporter value, and can never be generated through some externally-driven mechanism), then this part isn't strictly needed. Am I missing some context here, though?\n\n@muhammad-usama-sardar :\n\n> That's why it was explicitly stated in the [charter](https://datatracker.ietf.org/wg/seat/about/):\n\nSure! I guess we have the \"easy\" task of defining what it means / how it should be achieved now. Unfortunately \"binding\", or even \"cryptographic binding\" is quite loose as a concept, so we need to be aligned.\n",
          "createdAt": "2025-11-18T15:21:13Z",
          "updatedAt": "2025-11-18T15:21:13Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sure! I guess we have the \"easy\" task of defining what it means / how it should be achieved now. Unfortunately \"binding\", or even \"cryptographic binding\" is quite loose as a concept, so we need to be aligned.\n\nStill, in light of the charter, the title of this issue is misleading at best. Please update it to something more appropriate.\n\nAnd from your response, I am very confused. In the email pointing to this issue, you said that the purpose of this draft is not to go into specifics of TLS, and the comment above is implying towards that.",
          "createdAt": "2025-11-18T16:33:51Z",
          "updatedAt": "2025-11-18T16:33:51Z"
        },
        {
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Still, in light of the charter, the title of this issue is misleading at best. Please update it to something more appropriate.\n\nThanks, done.\n\n> In the email pointing to this issue, you said that the purpose of this draft is not to go into specifics of TLS, and the comment above is implying towards that.\n\nYeah, it's a bit difficult to balance this, because it's hard to discuss about how binding should be done or what it means without having an example where we can compare different approaches. Basically, we want the property to be more generic, but to explain and understand it better it makes more sense to discuss concrete examples.",
          "createdAt": "2025-11-18T17:06:57Z",
          "updatedAt": "2025-11-18T17:06:57Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do we need this property? To us it seems critical, but maybe we're mistaken.\n\n[Same arguments](https://github.com/tls-attestation/use-cases-and-properties/issues/14#issuecomment-3544058676) apply here as well. Please remove it.",
          "createdAt": "2025-11-21T15:42:55Z",
          "updatedAt": "2025-11-21T15:42:55Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Bind the AC to the attester's webPKI cert ...\n> Bind the webPKI cert to the (unique) attesting platform. ...\n\nWhy do you think these two options fulfill the charter requirements mentioned [here](https://github.com/tls-attestation/use-cases-and-properties/issues/14#issuecomment-3544058676)?",
          "createdAt": "2025-11-22T18:10:04Z",
          "updatedAt": "2025-11-22T18:10:04Z"
        },
        {
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Please remove it.\n\nDone.\n\n> Why do you think these two options fulfill the charter requirements mentioned here?\n\nBecause the charter doesn't explicitly state how the binding is achieved - it doesn't say it has to be through exported material. If the attestation credential is cryptographically bound to the TLS credential (let's say, the public part of the identity key), and that credential is used to sign the handshake transcript, I'd call that cryptographic binding.",
          "createdAt": "2025-11-28T14:25:37Z",
          "updatedAt": "2025-11-28T14:25:37Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "I agree with @ionut-arm that this issue is walking a thin line: define requirements without defining a specific solution.\n\nAlso, this is complicated because we are talking about a combination of cryptographic properties (what exactly gets signed in the AC) with system security properties: which software components must be endorsed. For example, even if the TLS stack is endorsed, it does not guarantee that *other* components are unable to get arbitrary stuff signed by the TEE.\n\nMy personal opinion is that given the constraints (namely, that some TEEs only accept a nonce input and cannot be modified to accept additional parameters and validate them) we can only achieve \"defense in depth\" - specify the best that can be done at each component (TLS stack, TEE shim library, TEE, RP) but assume than in any real deployment, only a subset will be implemented.",
          "createdAt": "2025-11-29T14:24:33Z",
          "updatedAt": "2025-11-29T14:24:33Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "> Because the charter doesn't explicitly state how the binding is achieved - it doesn't say it has to be through exported material. If the attestation credential is cryptographically bound to the TLS credential (let's say, the public part of the identity key), and that credential is used to sign the handshake transcript, I'd call that cryptographic binding.\n\nI disagree. Please draw and share a complete protocol diagram.\nMany use cases require runtime posture assessment. How do you do that?",
          "createdAt": "2025-12-01T08:18:50Z",
          "updatedAt": "2025-12-01T08:18:50Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "I_kwDOP_9tTM7YuLLc",
      "title": "Add a new operation-triggered use case of attested TLS",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/15",
      "state": "CLOSED",
      "author": "Yuning-J",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi,\n\nI propose the following operation-triggered use case of attested TLS, to be added into your existing use case draft [here](https://datatracker.ietf.org/doc/draft-mihalcea-seat-use-cases/):\n\n----------------------------------------------------\n3.4. Operation-Triggered Attestation for High-Impact Application Operations\n\nGoal: Ensure the integrity of application services at operation time, when security posture may change after initial channel establishment.\n\nUse case: High-Assurance Operation Execution in Dynamic Application Services: An application service instance (e.g., AI agent) or confidential computing environment (which could host an AI agent) maintains a (D)TLS connection with a peer and must execute a high-impact action (e.g., payment initiation, configuration change, privileged command).\n\nRequirement 1: Before executing a high-impact operation over the existing connection, the peer must presents fresh, connection-bound attestation evidence reflecting the current behavior-affecting posture (e.g., enabled capabilities, policy configuration, runtime permissions). \n\nRequirement 2: The mechanism SHOULD support lightweight, dynamic attestation within the existing connection, without necessarily requiring a full new TLS handshake, so that behavior-affecting posture changes are visible to relying parties when required by local policy.\n\n----------------------------------------------------\n\nAny comment and feedback are welcome to refine the descriptions.\n\n/Yuning",
      "createdAt": "2025-11-18T03:42:52Z",
      "updatedAt": "2025-11-30T14:59:10Z",
      "closedAt": "2025-11-30T14:59:10Z",
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @Yuning-J. I've moved this to PR #16. For any further changes, please make comments there.",
          "createdAt": "2025-11-18T09:09:18Z",
          "updatedAt": "2025-11-18T09:09:18Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed and merged #16 ",
          "createdAt": "2025-11-30T14:59:10Z",
          "updatedAt": "2025-11-30T14:59:10Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOP_9tTM7aoR8I",
      "title": "Paul's proposal of intra-handshake attestation",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/17",
      "state": "OPEN",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "muhammad-usama-sardar"
      ],
      "labels": [
        "Interim"
      ],
      "body": "[Archive link](https://mailarchive.ietf.org/arch/msg/seat/ophFdwJDybMMU4bWTBSmogkp6Bs/)\n\n> A standard webpki using a cert with two subjectAltname's, one for the PKI\n> (eg [www.example.com](http://www.example.com/)) and one for binding the TEE (eg\n> [tee-1234.www.example.com](http://tee-1234.www.example.com/)) along with a tee PKI that has a cert with\n> subjectAltname [tee-1234.www.example.com](http://tee-1234.www.example.com/))\n> \n> The tee PKI signs the attestation report. Both PKIs together give channel\n> binding and a binding between target domain name and server/tee instance.\n> The attestation report contains the TLS nonces for channel binding. The\n> subjectAltname also provides channel binding to the specific instance of\n> the tee, preventing a compromised server from using a modified tee, while\n> forwarding the request to a server/tee next to serving the same domain\n> using that tee which is left uncompromised.\n> \n> I'm sure there are other and hopefully even better ways to acomplish this.\n> It is just one example. Instead of jumping to post-handshake solutions that\n> have a clear disadvantage, the WG should really exhaust intra-handshake\n> options.",
      "createdAt": "2025-11-26T15:30:14Z",
      "updatedAt": "2025-12-15T09:05:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on meeting: (Attendees: Ionut, Thomas, Tiru, Yuning, Carsten, Usama, Yaron, Meiling Chen)\n\nTiru: No attested CSR solution does that. Point to RATS draft \nTiru: How is Attester proving to Verifier that the private key is stored in the key vault? How does Verifier know that it is actually stored in TEE?\n- Thomas: ad hoc appraisal on verifier side\n\nUsama: Could someone convert it to a protocol diagram that I can verify?\n",
          "createdAt": "2025-12-01T10:19:37Z",
          "updatedAt": "2025-12-01T10:32:08Z"
        },
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on meeting: (Attendees: Meiling, Tiru, Usama, Yuning)\n\n@ionut-arm can you make a protocol diagram for this? ",
          "createdAt": "2025-12-15T09:05:33Z",
          "updatedAt": "2025-12-15T09:05:33Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOP_9tTM7bX39J",
      "title": "Add use-cases diagrams",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/20",
      "state": "OPEN",
      "author": "ionut-arm",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We should have some diagrams that would help readers understand the topologies which might be relevant for the various use-cases documented. Each use-case would then highlight which topology is relevant, and identify which parties take which role (e.g., \"The Admin is a TLS client and relying party\").\n\nThe diagrams should show the basic set-up of a TLS connection between two peers, with one or both acting as attesters.\n\nIf some of the use-cases require more complex diagrams, those can be handled on a case-by-case basis.",
      "createdAt": "2025-12-01T11:07:59Z",
      "updatedAt": "2025-12-01T11:07:59Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOP_9tTM7c3a74",
      "title": "Reference for use cases",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/issues/21",
      "state": "OPEN",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@tireddy2 proposed to add one reference for each use case. I think it will be a valuable addition.",
      "createdAt": "2025-12-08T09:37:59Z",
      "updatedAt": "2025-12-08T09:37:59Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOP_9tTM6tdQ-K",
      "title": "update CODEOWNERS",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/pull/1",
      "state": "MERGED",
      "author": "thomas-fossati",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add Usama and Thomas to the CODEOWNERS\r\n\r\nThis should make it easier for any of us to submit via the release button.",
      "createdAt": "2025-10-13T12:46:59Z",
      "updatedAt": "2025-10-13T14:28:16Z",
      "baseRepository": "tls-attestation/use-cases-and-properties",
      "baseRefName": "main",
      "baseRefOid": "60b0b83275daf225d204523527912b2bb8536756",
      "headRepository": "tls-attestation/use-cases-and-properties",
      "headRefName": "codeownerz",
      "headRefOid": "d94b5bf3f22f480b35bcc08ac8d35ce7404003cb",
      "closedAt": "2025-10-13T14:28:12Z",
      "mergedAt": "2025-10-13T14:28:12Z",
      "mergedBy": "thomas-fossati",
      "mergeCommit": {
        "oid": "080e68a1f8ee3ff7d4a416091fe00952073286b7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOP_9tTM7Glwyv",
          "commit": {
            "abbreviatedOid": "d94b5bf"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-13T14:05:52Z",
          "updatedAt": "2025-10-13T14:05:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDOP_9tTM6tiKkV",
      "title": "Binding property + minor terminology update",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/pull/2",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "s/session/connection",
      "createdAt": "2025-10-13T20:19:34Z",
      "updatedAt": "2025-10-19T17:34:22Z",
      "baseRepository": "tls-attestation/use-cases-and-properties",
      "baseRefName": "main",
      "baseRefOid": "080e68a1f8ee3ff7d4a416091fe00952073286b7",
      "headRepository": "muhammad-usama-sardar/use-cases-and-properties",
      "headRefName": "patch-1",
      "headRefOid": "f238c49030cdab8f312102b17f931ce54d338642",
      "closedAt": "2025-10-19T17:34:22Z",
      "mergedAt": "2025-10-19T17:34:22Z",
      "mergedBy": "ionut-arm",
      "mergeCommit": {
        "oid": "95ebd4c911c22cf2f732561fdde4b1f2de15b81a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOP_9tTM7GwaUA",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "LGTM.  I have left a suggestion inline to fix the broken YAML.",
          "createdAt": "2025-10-14T08:55:03Z",
          "updatedAt": "2025-10-14T08:56:04Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n    Meeting-122-TLS-Slides:\r\n     title: \"Identity Crisis in Attested TLS for Confidential Computing\"\r\n     date: 20 March 2025,\r\n     target: https://datatracker.ietf.org/meeting/122/materials/slides-122-tls-identity-crisis-00\r\n     author:\r\n     - ins: M. U. Sardar\r\n     - ins: M. Moustafa\r\n     - ins: T. Aura\r\n```",
              "createdAt": "2025-10-14T08:55:03Z",
              "updatedAt": "2025-10-14T08:56:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GwkcQ",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:06:22Z",
          "updatedAt": "2025-10-14T09:06:22Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Thanks, it somehow worked as is [here](https://github.com/muhammad-usama-sardar/tls-fatt-extension/blob/main/draft-usama-tls-fatt-extension.md?plain=1). I just copied and pasted from there. Just for my knowledge, is there a difference of configuration that makes it work there?",
              "createdAt": "2025-10-14T09:06:22Z",
              "updatedAt": "2025-10-14T09:06:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GwpEz",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:11:21Z",
          "updatedAt": "2025-10-14T09:11:21Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It's not a matter of configuration; it's the context that matters.  You need to match the surrounding indentation pattern.",
              "createdAt": "2025-10-14T09:11:21Z",
              "updatedAt": "2025-10-14T09:11:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Gwp12",
          "commit": {
            "abbreviatedOid": "e25abe7"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:12:14Z",
          "updatedAt": "2025-10-14T09:12:24Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Can you expand on `provider`?  One option below.\r\n\r\n```suggestion\r\n## Cryptographic Binding to Platform Provider Identity\r\n\r\nEvidence should be cryptographically bound to the platform provider identity to prevent diversion attacks {{Meeting-122-TLS-Slides}}.\r\n```\r\n\r\nI'm not convinced that's what you meant, though",
              "createdAt": "2025-10-14T09:12:14Z",
              "updatedAt": "2025-10-14T09:12:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Gw3B2",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:26:46Z",
          "updatedAt": "2025-10-14T09:26:47Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "It could be a cloud provider if VM is running on the cloud, or otherwise some other infrastructure provider.\r\nWould 'infrastructure provider' be better? We can wordsmith it. ",
              "createdAt": "2025-10-14T09:26:46Z",
              "updatedAt": "2025-10-14T09:26:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Gw_NR",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:36:03Z",
          "updatedAt": "2025-10-14T09:36:04Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Sure, infrastructure provider is better, though is the entire phrase accurate? By which I mean, is it the \"infrastructure provider identity\" that is bound, or the \"infrastructure identity\"?",
              "createdAt": "2025-10-14T09:36:03Z",
              "updatedAt": "2025-10-14T09:36:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GxCvo",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:40:15Z",
          "updatedAt": "2025-10-14T09:40:15Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I understand the diversion being triggered by the lack of \"unique machine identity\u201d, regardless of who the identity provider is.\r\n\r\nP.S.: Using the word \u201cidentity\" tends to lead people down rabbit holes.",
              "createdAt": "2025-10-14T09:40:15Z",
              "updatedAt": "2025-10-14T09:40:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GxODl",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:52:54Z",
          "updatedAt": "2025-10-14T09:52:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Then maybe `Cryptographic binding to unique machine identifier` is better?",
              "createdAt": "2025-10-14T09:52:54Z",
              "updatedAt": "2025-10-14T09:52:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GxR72",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T09:57:24Z",
          "updatedAt": "2025-10-14T09:57:24Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "How about \"identifier of infrastructure provider\"?\r\n\r\n> I understand the diversion being triggered by the lack of \"unique machine identity\u201d, regardless of who the identity provider is.\r\n\r\nI don't expect cloud providers to reveal unique machine identifiers. I think \"identity provider\" should be in the trust anchor store. ",
              "createdAt": "2025-10-14T09:57:24Z",
              "updatedAt": "2025-10-14T09:57:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GxfUE",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T10:13:45Z",
          "updatedAt": "2025-10-14T10:13:46Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "> I don't expect cloud providers to reveal unique machine identifiers.\r\n\r\nHmm, that's fair.\r\n\r\n> How about \"identifier of infrastructure provider\"?\r\n\r\nThat works. Another option is \"infrastructure provider credential\"",
              "createdAt": "2025-10-14T10:13:46Z",
              "updatedAt": "2025-10-14T10:13:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Gx8Ds",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T10:49:46Z",
          "updatedAt": "2025-10-14T10:49:46Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "> > I don't expect cloud providers to reveal unique machine identifiers.\r\n> \r\n> Hmm, that's fair.\r\n\r\nWhether or not the machine identifier is revealed is irrelevant.  What matters is that a given machine can prove its identity to the credential provider and that this identity is used to create the binding credential.\r\n\r\n> > How about \"identifier of infrastructure provider\"?\r\n> \r\n> That works. Another option is \"infrastructure provider credential\"\r\n\r\nSorry, I don\u2019t like either :-)\r\n\r\n",
              "createdAt": "2025-10-14T10:49:46Z",
              "updatedAt": "2025-10-14T10:49:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GyYw_",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T11:23:52Z",
          "updatedAt": "2025-10-14T11:23:52Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "> > > I don't expect cloud providers to reveal unique machine identifiers.\r\n> > \r\n> > \r\n> > Hmm, that's fair.\r\n> \r\n> Whether or not the machine identifier is revealed is irrelevant. What matters is that a given machine can prove its identity to the credential provider and that this identity is used to create the binding credential.\r\n> \r\n\r\nWhat does \"identity\" entail here? Also, that seems only applicable to the passport model. \r\n> > > How about \"identifier of infrastructure provider\"?\r\n> > \r\n> > \r\n> > That works. Another option is \"infrastructure provider credential\"\r\n> \r\n> Sorry, I don\u2019t like either :-)\r\n\r\nYou are in the rough :P",
              "createdAt": "2025-10-14T11:23:52Z",
              "updatedAt": "2025-10-14T11:23:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GzIGG",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T12:14:10Z",
          "updatedAt": "2025-10-14T12:14:11Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "> > Whether or not the machine identifier is revealed is irrelevant. What matters is that a given machine can prove its identity to the credential provider and that this identity is used to create the binding credential.\r\n>\r\n> What does \"identity\" entail here?\r\n\r\nThe ability to single out a given machine (or a group of machines in an anonymity group).\r\n\r\n> Also, that seems only applicable to the passport model.\r\n\r\nWhy?  Not at all.",
              "createdAt": "2025-10-14T12:14:10Z",
              "updatedAt": "2025-10-14T12:14:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7GzUMy",
          "commit": {
            "abbreviatedOid": "1dbb626"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2025-10-14T12:26:19Z",
          "updatedAt": "2025-10-14T12:26:26Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I don\u2019t think this should be about the \u201cidentifier of the infra provider\u201d.\r\nIt should be about an \u201cidentifier provided to the machine by the infra provider\u201d.",
              "createdAt": "2025-10-14T12:26:19Z",
              "updatedAt": "2025-10-14T13:00:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Gzx7V",
          "commit": {
            "abbreviatedOid": "48b4eb7"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T12:54:16Z",
          "updatedAt": "2025-10-14T12:54:16Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "> Also, that seems only applicable to the passport model.\r\n\r\nMust've forgotten the model before, but I think the whole flow was something like:\r\n\r\n* New device gets added to a provider's estate.\r\n* Provider issues a credential for the device (and potentially provisions cryptographic material to go with it too); the credential specifies who the provider is, where the device is located etc.\r\n* Workload on the device tries to use aTLS, including binding to the device credential; you therefore need to somehow bind the session to this credential\r\n\r\nIf I understand correctly, we're all talking about this last step. Don't think it's passport model specifically, the device credential must've been issued before, but the background check/passport does not relate to this credential.",
              "createdAt": "2025-10-14T12:54:16Z",
              "updatedAt": "2025-10-14T12:54:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7G2-AV",
          "commit": {
            "abbreviatedOid": "1dbb626"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-14T15:34:31Z",
          "updatedAt": "2025-10-14T15:34:31Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "ok, that works for me. ",
              "createdAt": "2025-10-14T15:34:31Z",
              "updatedAt": "2025-10-14T15:34:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HA5yS",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T07:51:40Z",
          "updatedAt": "2025-10-15T07:51:40Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "We should make it clear that the diversion attack is deployment- and architecture-specific.\r\n\r\n```suggestion\r\nIn certain deployments and for specific hardware architectures, diversion attacks are possible {{Meeting-122-TLS-Slides}}.\r\nTo prevent such an attack, Evidence should be cryptographically bound to the identifier provided to the machine by the infrastructure provider.\r\n```",
              "createdAt": "2025-10-15T07:51:40Z",
              "updatedAt": "2025-10-15T08:01:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HCWNQ",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T09:13:54Z",
          "updatedAt": "2025-10-15T09:13:55Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Makes sense, makes me wonder whether we should add qualifiers for the other properties too.",
              "createdAt": "2025-10-15T09:13:54Z",
              "updatedAt": "2025-10-15T09:13:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HE11k",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T11:40:22Z",
          "updatedAt": "2025-10-15T11:40:22Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I don't disagree, but I don't have any specific suggestions except for this one right now.",
              "createdAt": "2025-10-15T11:40:22Z",
              "updatedAt": "2025-10-15T11:40:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HFP1i",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T12:09:22Z",
          "updatedAt": "2025-10-15T12:09:22Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> We should make it clear that the diversion attack is deployment- and architecture-specific.\r\n\r\nI would like to see at least one concrete counterexample of an _existing_ deployment and/or hardware architecture where this attack is not applicable. ",
              "createdAt": "2025-10-15T12:09:22Z",
              "updatedAt": "2025-10-15T12:09:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HFRad",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T12:11:14Z",
          "updatedAt": "2025-10-15T12:11:15Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Arm CCA with per-machine instance ID?",
              "createdAt": "2025-10-15T12:11:14Z",
              "updatedAt": "2025-10-15T12:11:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HFnjt",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T12:34:16Z",
          "updatedAt": "2025-10-15T12:34:16Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "There is no _existing_ deployment for Arm CCA yet, right? And that needs more discussion as in how that would identify that this machine is in a cloud provider's data center. Anyway, I propose we leave as it is, because it is one of the requirements that our protocol design needs to satisfy. This document -- at least the way I am thinking of it -- is just describing our requirements for protocol design and we agree that it is a requirement. Whether it is deployment-specific or hardware architecture-specific does not matter for this document in my view. \r\nIf we really want to qualify it, we should thoroughly discuss how Arm CCA avoids this and then qualify other properties too. ",
              "createdAt": "2025-10-15T12:34:16Z",
              "updatedAt": "2025-10-15T12:34:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HGEXk",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T12:55:50Z",
          "updatedAt": "2025-10-15T12:55:51Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> [\u2026] how that would identify that this machine is in a cloud provider's data center\r\n\r\nWe have already discussed this point: via an endorsement that binds the machine\u2019s instance ID with the network/geographical location.",
              "createdAt": "2025-10-15T12:55:50Z",
              "updatedAt": "2025-10-15T12:55:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7HHHvg",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-15T13:52:46Z",
          "updatedAt": "2025-10-15T13:52:46Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Stepping a bit back, we should have a clear separation between things that are strictly necessary regardless of the underlying technologies, and those that depend on how these technologies work, even if some conditions are not met in deployments right now. Don't think our intent should be to write specs only for what exists right now.\r\n\r\nAs an example, the cryptographic binding between RA and Secure Channel (SC) sessions should always be there one way or another, otherwise RA is useless. No change to platform / RA / TLS can be enough to overcome that.",
              "createdAt": "2025-10-15T13:52:46Z",
              "updatedAt": "2025-10-15T13:52:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7H5I6E",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-18T16:17:48Z",
          "updatedAt": "2025-10-18T16:17:48Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> We have already discussed this point: via an endorsement that binds the machine\u2019s instance ID with the network/geographical location.\r\n\r\nI said _thorough_ discussions vs. top-of-head discussions.\r\n\r\n- Who provides this Endorsement in the real world? Please point me to one concrete specification and one concrete deployment.\r\n- Please name one concrete cloud provider that provides such machine\u2019s instance ID in the Evidence. Without this, the Endorsement is useless.",
              "createdAt": "2025-10-18T16:17:48Z",
              "updatedAt": "2025-10-18T16:17:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7H5MGd",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-18T16:51:20Z",
          "updatedAt": "2025-10-18T16:51:20Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> we should have a clear separation between things that are strictly necessary regardless of the underlying technologies, and those that depend on how these technologies work\r\n\r\nMy point is: it is not followed in the rest of the document. For example, \"Performance and Efficiency\" in the draft is also dependent on the underlying technology. Why are we emphasizing it here only?\r\n\r\nThe purpose is to list the requirements, and we agree that it is a requirement. Whether some technology fulfills it or not is not the aim of this document. Let's not make it a technology comparison document. ",
              "createdAt": "2025-10-18T16:51:20Z",
              "updatedAt": "2025-10-18T16:51:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7H5m2m",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "thomas-fossati",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-10-18T20:31:48Z",
          "updatedAt": "2025-10-18T20:31:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOP_9tTM7H8zac",
          "commit": {
            "abbreviatedOid": "f238c49"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-10-19T17:34:00Z",
          "updatedAt": "2025-10-19T17:34:00Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> My point is: it is not followed in the rest of the document. For example, \"Performance and Efficiency\" in the draft is also dependent on the underlying technology. Why are we emphasizing it here only?\r\n\r\nAgree, and I was keen to follow this one up and make it uniform, it's just something that didn't occur to me the first time around. I'll open an issue to address in a future revision.\r\n\r\n> The purpose is to list the requirements, and we agree that it is a requirement.\r\n\r\nAgree here too, but as I pointed out above, there are also nuances that should be made clear _somewhere_ for people who want to deploy something.",
              "createdAt": "2025-10-19T17:34:00Z",
              "updatedAt": "2025-10-19T17:34:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOP_9tTM60DK-I",
      "title": "AI agent use case by Yuning: issue #15",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/pull/16",
      "state": "MERGED",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just relaying the text from Yuning in issue #15\r\n\r\nSummary of changes in Yuning's text: \r\n- Replaced normative SHOULD by should (I think informative doc cannot have normative SHOULD) \r\n- Applied some formatting (such as line breaks) for readability\r\n- Added Yuning as co-author",
      "createdAt": "2025-11-18T09:06:40Z",
      "updatedAt": "2025-12-01T02:21:14Z",
      "baseRepository": "tls-attestation/use-cases-and-properties",
      "baseRefName": "main",
      "baseRefOid": "95ebd4c911c22cf2f732561fdde4b1f2de15b81a",
      "headRepository": "tls-attestation/use-cases-and-properties",
      "headRefName": "ai-agent",
      "headRefOid": "bdf6cae198a63eb5cbf5a74ba5e652f7152a4eab",
      "closedAt": "2025-11-30T14:58:19Z",
      "mergedAt": "2025-11-30T14:58:19Z",
      "mergedBy": "muhammad-usama-sardar",
      "mergeCommit": {
        "oid": "4cf46b26ed00e502eec0895b2b448c7bda9d685f"
      },
      "comments": [
        {
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks very much once again @Yuning-J. Ready to merge from my side. ",
          "createdAt": "2025-11-30T14:54:54Z",
          "updatedAt": "2025-11-30T14:54:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOP_9tTM7QOQ1I",
          "commit": {
            "abbreviatedOid": "4c092bc"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "some questions need to be clarified before merging.",
          "createdAt": "2025-11-21T15:59:01Z",
          "updatedAt": "2025-11-21T16:04:33Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "What is the secret that the peer has to send to the Attester?",
              "createdAt": "2025-11-21T15:59:01Z",
              "updatedAt": "2025-11-21T16:04:33Z"
            },
            {
              "originalPosition": 25,
              "body": "s/presents/present",
              "createdAt": "2025-11-21T15:59:45Z",
              "updatedAt": "2025-11-21T16:04:33Z"
            },
            {
              "originalPosition": 31,
              "body": "I don't understand how the `so that ...` part follows from the previous description. Why exactly is a lightweight attestation preferable over a full new TLS handshake?",
              "createdAt": "2025-11-21T16:02:15Z",
              "updatedAt": "2025-11-21T16:04:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7QbzI5",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "more questions",
          "createdAt": "2025-11-22T21:14:48Z",
          "updatedAt": "2025-11-22T22:18:24Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Is \"long-running\" really necessary? If yes, why?",
              "createdAt": "2025-11-22T21:14:48Z",
              "updatedAt": "2025-11-22T22:18:24Z"
            },
            {
              "originalPosition": 38,
              "body": "How does the RP know that the _high-impact operation_ is now going to be performed? (e.g., that the agent is about to book a flight)",
              "createdAt": "2025-11-22T22:00:17Z",
              "updatedAt": "2025-11-22T22:18:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7QkCcD",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-24T09:03:48Z",
          "updatedAt": "2025-11-24T09:03:48Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Add reference.",
              "createdAt": "2025-11-24T09:03:48Z",
              "updatedAt": "2025-11-24T09:03:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Rrybn",
          "commit": {
            "abbreviatedOid": "4c092bc"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-28T08:27:30Z",
          "updatedAt": "2025-11-28T08:27:30Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The secret that the peer has to send to the Attester is a nonce (for freshness) or a TLS key exporter value (for channel binding). We need to prove that the entity holding the private key for the TLS connection is the same entity inside the TEE.\r\n\r\n(While I believe the specific wire-format fields belong to the solution definition rather than the use case, the intention here is to ensure freshness and channel binding.)\r\n",
              "createdAt": "2025-11-28T08:27:30Z",
              "updatedAt": "2025-11-28T08:27:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Rrzk-",
          "commit": {
            "abbreviatedOid": "4c092bc"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-28T08:28:33Z",
          "updatedAt": "2025-11-28T08:28:34Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "There are two primary drivers for this requirement:\r\n\u2981\tHigh-impact operations often happen in the middle of complex, stateful application flows (e.g., a multi-turn AI agent conversation). Forcing a full TLS handshake often implies tearing down the underlying transport, which can disrupt application context/buffers. We need to verify security posture without dropping the application state.\r\n\u2981\tIf an application needs to verify integrity before every sensitive micro-transaction, a lightweight re-attestation token within the existing tunnel is significantly more performant than renegotiating the entire connection.\r\n",
              "createdAt": "2025-11-28T08:28:33Z",
              "updatedAt": "2025-11-28T08:28:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Rrz8I",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-28T08:28:52Z",
          "updatedAt": "2025-11-28T08:28:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Yes, \"long-running\" is the condition that creates the vulnerability (e.g., TOCTOU). But we are open to remove this if all the authors believe this is unnecessary condition.",
              "createdAt": "2025-11-28T08:28:52Z",
              "updatedAt": "2025-11-28T08:28:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Rr7DY",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-28T08:38:51Z",
          "updatedAt": "2025-11-28T08:38:51Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This is triggered by the Application Layer, based on local policy and application semantics.\r\n\r\nThe draft does not attempt to standardize the policy language or signaling itself --> only the requirement that SEAT solutions must support obtaining fresh, channel-bound Evidence when such a policy chooses to trigger it.",
              "createdAt": "2025-11-28T08:38:51Z",
              "updatedAt": "2025-11-28T08:38:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7RwwgC",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for the use-case! Left a couple of comments, but overall it sounds like a good addition to me already.",
          "createdAt": "2025-11-28T14:36:02Z",
          "updatedAt": "2025-11-28T14:38:56Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Reference for which part in particular?",
              "createdAt": "2025-11-28T14:36:02Z",
              "updatedAt": "2025-11-28T14:38:56Z"
            },
            {
              "originalPosition": 14,
              "body": "Agree that \"long-running\" is an important factor, IMO it's not problematic.\r\n\r\nIf I remember correctly, the problematic part was around self-modifying agents, but I don't see that encoded here.",
              "createdAt": "2025-11-28T14:38:01Z",
              "updatedAt": "2025-11-28T14:38:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Rw3rx",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-28T14:46:12Z",
          "updatedAt": "2025-11-28T14:46:12Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Sorry, I did not phrase it out well enough. \r\nJust to be clear, I completely agree that long-running is the most relevant use case. My question just is: is every AI agent long-running? i.e., is it necessarily a part of the definition itself? or just that some agents may be long running and some may not be.",
              "createdAt": "2025-11-28T14:46:12Z",
              "updatedAt": "2025-11-28T14:46:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Rw32j",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-28T14:46:28Z",
          "updatedAt": "2025-11-28T14:46:29Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Reference for definition",
              "createdAt": "2025-11-28T14:46:28Z",
              "updatedAt": "2025-11-28T14:46:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7Rw5dQ",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-28T14:48:21Z",
          "updatedAt": "2025-11-28T14:48:21Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Sorry, again my bad for not phrasing out question precisely. I meant what is the secret that peer will send _after attestation_ to the Attester?",
              "createdAt": "2025-11-28T14:48:21Z",
              "updatedAt": "2025-11-28T14:48:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R1T1N",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-29T02:32:41Z",
          "updatedAt": "2025-11-29T02:32:41Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Many commonly used frameworks such as [LangChain](https://docs.langchain.com/oss/python/langchain/agents) clearly frame the Control Plane of an AI agent, as described in this use case that \"Its configuration (e.g., model choice, tool enablement, prompt template)...\". These frameworks define agents primarily through configuration files (YAML/JSON) that specify the model_name, temperature, and tools list. These configs are designed to be hot-swappable. One can change an agent's behavior drastically (e.g., \"Switch from safe Model A to experimental Model B\" or \"Give Agent X access to the SQL Database tool\") just by changing a JSON config file or an environment variable. Such characters are also introduced in papers such as [link1](https://arxiv.org/pdf/2507.21046) and [link2](https://arxiv.org/pdf/2508.07407).\r\n\r\n\"_AI systems may require more frequent maintenance and triggers for conducting corrective maintenance due to data, model, or concept drift_.\" and other similar statements in the [NIST AI Risk Management Framework (AI RMF)](https://www.nist.gov/itl/ai-risk-management-framework).",
              "createdAt": "2025-11-29T02:32:41Z",
              "updatedAt": "2025-11-29T02:32:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R23Eh",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-29T20:39:51Z",
          "updatedAt": "2025-11-29T20:39:51Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Sure, just to clarify: The intention here is to define AI agent in the sense we will use at SEAT. So could you please propose a single reference that we can use as a reference for this definition?",
              "createdAt": "2025-11-29T20:39:51Z",
              "updatedAt": "2025-11-29T20:39:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R4Zv9",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-30T10:29:05Z",
          "updatedAt": "2025-11-30T10:29:06Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Thanks, that\u2019s a good clarification point.\r\nI do not intend \u201clong-running\u201d to be part of the definition of an AI agent. Long-running or multiplexed sessions are just a common pattern where this is especially visible, not a definitional aspect of AI agent. I\u2019m happy to adjust the wording if all agree.",
              "createdAt": "2025-11-30T10:29:06Z",
              "updatedAt": "2025-11-30T10:29:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R4brh",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-30T10:53:09Z",
          "updatedAt": "2025-11-30T10:53:09Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I would then recommend to keep [1] as the primary reference for how we use AI agent in our use case draft, and in addition cite [2] and [3] where we specifically talk about configuration-driven behavior (model choice, tool enablement, prompts, etc.).\r\nAs far as I\u2019m aware, there is no requirement in IETF documents that a definition or statement be supported by exactly one reference; it\u2019s quite common to point to several complementary works when a concept is still evolving. In our case, [1] anchors the general notion of agentic AI systems, while [2] and [3] provide concrete architectural decompositions (model + context + tools + workflow) that directly motivate the configuration aspects we describe.\r\n\r\n[1] Kapoor, S., Stroebl, B., Siegel, Z. S., Nadgir, N., & Narayanan, A. (2024). Ai agents that matter. arXiv preprint arXiv:2407.01502.\r\n[2] Gao, H. A., Geng, J., Hua, W., Hu, M., Juan, X., Liu, H., ... & Wang, M. (2025). A survey of self-evolving agents: On path to artificial super intelligence. arXiv preprint arXiv:2507.21046.\r\n[3] Fang, J., Peng, Y., Zhang, X., Wang, Y., Yi, X., Zhang, G., ... & Meng, Z. (2025). A comprehensive survey of self-evolving ai agents: A new paradigm bridging foundation models and lifelong agentic systems. arXiv preprint arXiv:2508.07407.",
              "createdAt": "2025-11-30T10:53:09Z",
              "updatedAt": "2025-11-30T10:53:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R4en4",
          "commit": {
            "abbreviatedOid": "4c092bc"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-30T11:21:18Z",
          "updatedAt": "2025-11-30T11:21:19Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "In this use case I\u2019m not assuming a new secret beyond what the application already treats as sensitive. The pattern is:\r\n\r\n- The Attester (e.g., an AI agent runtime) presents fresh, channel-bound Evidence for the current TLS session.\r\n- The Relying Party (RP) then decides whether it is willing to proceed with some high-impact operation over that same TLS connection.\r\n- If the appraisal result is acceptable, the RP may send data or capabilities that it otherwise would not send, that is the \u201csecret\u201d in the usual RATS template.",
              "createdAt": "2025-11-30T11:21:19Z",
              "updatedAt": "2025-11-30T11:21:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R476t",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-30T14:26:30Z",
          "updatedAt": "2025-11-30T14:26:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "> I\u2019m happy to adjust the wording\r\n\r\nYes, please propose a revised definition. If that is a common pattern, it could words like \"typically\" but not make it absolute that every AI agent is long-running.",
              "createdAt": "2025-11-30T14:26:30Z",
              "updatedAt": "2025-11-30T14:26:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R496a",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-30T14:29:38Z",
          "updatedAt": "2025-11-30T14:29:38Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I am a bit hesitant to put self-evolving agents in [2] and [3] because of the discussion in the last meeting. I'll put [1] for now and discuss tomorrow.",
              "createdAt": "2025-11-30T14:29:38Z",
              "updatedAt": "2025-11-30T14:29:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R5NXl",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-11-30T14:51:38Z",
          "updatedAt": "2025-11-30T14:51:39Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I slightly updated it to reflect it. Please check if it is ok.",
              "createdAt": "2025-11-30T14:51:38Z",
              "updatedAt": "2025-11-30T14:51:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7R_BXH",
          "commit": {
            "abbreviatedOid": "17d6556"
          },
          "author": "Yuning-J",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T02:21:14Z",
          "updatedAt": "2025-12-01T02:21:14Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Your modified version looks good to me. Thanks.",
              "createdAt": "2025-12-01T02:21:14Z",
              "updatedAt": "2025-12-01T02:21:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOP_9tTM62RpZw",
      "title": "#4, #12 and Use case by Meiling Chen",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/pull/18",
      "state": "OPEN",
      "author": "muhammad-usama-sardar",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- #4 Reordering first two use cases  \r\n- #12 phrase as requirement \r\n- Relaying the text from Chen Meiling with small formatting changes",
      "createdAt": "2025-12-01T07:34:34Z",
      "updatedAt": "2025-12-08T10:00:22Z",
      "baseRepository": "tls-attestation/use-cases-and-properties",
      "baseRefName": "main",
      "baseRefOid": "4cf46b26ed00e502eec0895b2b448c7bda9d685f",
      "headRepository": "tls-attestation/use-cases-and-properties",
      "headRefName": "ai-agent",
      "headRefOid": "de85314785bc34045c90aa8faf4d5c436a2a1ec5",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOP_9tTM7SDHbQ",
          "commit": {
            "abbreviatedOid": "a4c986d"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T09:28:41Z",
          "updatedAt": "2025-12-01T09:28:42Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Network devices (TLS client) is Attester. \r\nNetwork orchestrator (TLS server) is RP. ",
              "createdAt": "2025-12-01T09:28:42Z",
              "updatedAt": "2025-12-01T09:28:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SF2xp",
          "commit": {
            "abbreviatedOid": "fa0cea7"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T12:29:55Z",
          "updatedAt": "2025-12-01T12:29:55Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "We need to clarify if there is something unique in this use case, compared to other use cases.",
              "createdAt": "2025-12-01T12:29:55Z",
              "updatedAt": "2025-12-01T12:29:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOP_9tTM62SXvT",
      "title": "Added a new section to discuss run-time attestation",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/pull/19",
      "state": "MERGED",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-12-01T08:35:32Z",
      "updatedAt": "2025-12-02T04:50:55Z",
      "baseRepository": "tls-attestation/use-cases-and-properties",
      "baseRefName": "main",
      "baseRefOid": "4cf46b26ed00e502eec0895b2b448c7bda9d685f",
      "headRepository": "tireddy2/use-cases-and-properties",
      "headRefName": "main",
      "headRefOid": "c12de37f391af4deebefad0e6d73fcb02b16ccca",
      "closedAt": "2025-12-02T04:50:54Z",
      "mergedAt": "2025-12-02T04:50:54Z",
      "mergedBy": "tireddy2",
      "mergeCommit": {
        "oid": "8a3ac3fc2308144cd7755165d5c0a5bb580d7c54"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOP_9tTM7SDfQ2",
          "commit": {
            "abbreviatedOid": "02b4fd3"
          },
          "author": "ionut-arm",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Could you also remove the property before yours (`Credential Lifecycle Management`) - that was intended to convey basically what you're proposing, just more succinctly. Your write-up is better, though!\r\n\r\nI also wonder whether there should be a mention somewhere that runtime attestation should be performant or lightweight.",
          "createdAt": "2025-12-01T09:50:38Z",
          "updatedAt": "2025-12-01T09:55:55Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Ideally the properties should be protocol-agnostic.  This is just the first case, the others below should also be changed, if you want I can provide similar change suggestions.\r\n```suggestion\r\nEvidence collected at certificate issuance or during the initial secure channel establishment reflects only the platform\u2019s state at that moment. It cannot\r\n```\r\n(sorry, couldn't format it properly)",
              "createdAt": "2025-12-01T09:50:38Z",
              "updatedAt": "2025-12-01T09:55:24Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nmay change state after the connection is established and the connection is long-lived.\r\n```",
              "createdAt": "2025-12-01T09:51:16Z",
              "updatedAt": "2025-12-01T09:55:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SHaDu",
          "commit": {
            "abbreviatedOid": "02b4fd3"
          },
          "author": "thomas-fossati",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T14:01:56Z",
          "updatedAt": "2025-12-01T14:01:56Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "In general, \u201cplatform\" is just a subset of the target environment.\r\n\r\n```suggestion\r\nhandshake reflects only the attester's state at that moment. It cannot\r\n```",
              "createdAt": "2025-12-01T14:01:56Z",
              "updatedAt": "2025-12-01T14:02:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SHbbo",
          "commit": {
            "abbreviatedOid": "02b4fd3"
          },
          "author": "thomas-fossati",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T14:03:15Z",
          "updatedAt": "2025-12-01T14:03:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "ditto\r\n\r\n```suggestion\r\nguarantee that the target environment remains trustworthy for the lifetime of the\r\n```",
              "createdAt": "2025-12-01T14:03:15Z",
              "updatedAt": "2025-12-01T14:03:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SHcno",
          "commit": {
            "abbreviatedOid": "02b4fd3"
          },
          "author": "thomas-fossati",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T14:04:27Z",
          "updatedAt": "2025-12-01T14:04:28Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nmay change state during the lifetime of the connection.\r\n```",
              "createdAt": "2025-12-01T14:04:27Z",
              "updatedAt": "2025-12-01T14:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SHmgH",
          "commit": {
            "abbreviatedOid": "02b4fd3"
          },
          "author": "thomas-fossati",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T14:13:45Z",
          "updatedAt": "2025-12-01T14:13:45Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nRuntime attestation closes this gap by enabling the Relying Party (RP) to request new attestation evidence once the TLS connection has been established, or periodically during long-lived connections if necessary.\r\nThis may be the case when the target environment has attributes that can change during the connection, affecting its trustworthiness. Such changes cannot be detected using evidence collected earlier.\r\nFor example, the evidence may include dynamic parameters such as runtime configuration flags (e.g., FIPS mode), where a device may enter or exit an approved mode, or measurements of critical system files.\r\n```",
              "createdAt": "2025-12-01T14:13:45Z",
              "updatedAt": "2025-12-01T14:15:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SHtHq",
          "commit": {
            "abbreviatedOid": "02b4fd3"
          },
          "author": "thomas-fossati",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM.  I added a few edits to improve precision.\r\n\r\nI suggest we use the NLNS (new line, new sentence) convention rather than splitting the line at an arbitrary number of columns.\r\nIME, once a line is modified, this helps focusing on the semantic change rather than having to reconstruct the fragmented flow.",
          "createdAt": "2025-12-01T14:19:59Z",
          "updatedAt": "2025-12-01T14:19:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOP_9tTM7SH4eX",
          "commit": {
            "abbreviatedOid": "ce507a1"
          },
          "author": "thomas-fossati",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T14:29:04Z",
          "updatedAt": "2025-12-01T14:29:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I suggest avoiding the term \u201cplatform\", as this is only a subset of what is measured in attestation evidence.\r\n\r\nInstead, use \u201cattester\u201d or, more precisely, \"target environment\", as per RFC9334.",
              "createdAt": "2025-12-01T14:29:04Z",
              "updatedAt": "2025-12-01T14:29:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SIx3N",
          "commit": {
            "abbreviatedOid": "ce507a1"
          },
          "author": "muhammad-usama-sardar",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-01T15:11:53Z",
          "updatedAt": "2025-12-01T15:11:53Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nEvidence collected at certificate issuance or during the initial secure channel establishment reflects only the Target Environment\u2019s state at that moment. It cannot guarantee that the Target Environment remains trustworthy for the lifetime of the certificate or even for the duration of the TLS session. As a result, such static evidence is insufficient in environments where the Target Environment may change state after the connection is established and the connection is long-lived.\r\n```",
              "createdAt": "2025-12-01T15:11:53Z",
              "updatedAt": "2025-12-01T15:13:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOP_9tTM7SSs__",
          "commit": {
            "abbreviatedOid": "ce507a1"
          },
          "author": "tireddy2",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-12-02T04:50:29Z",
          "updatedAt": "2025-12-02T04:50:29Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Fixed. ",
              "createdAt": "2025-12-02T04:50:29Z",
              "updatedAt": "2025-12-02T04:50:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOP_9tTM642xeo",
      "title": "New use case \"Attestation of Certificate Private Key\"",
      "url": "https://github.com/tls-attestation/use-cases-and-properties/pull/22",
      "state": "OPEN",
      "author": "tireddy2",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-12-15T07:34:22Z",
      "updatedAt": "2025-12-15T08:40:59Z",
      "baseRepository": "tls-attestation/use-cases-and-properties",
      "baseRefName": "main",
      "baseRefOid": "8a3ac3fc2308144cd7755165d5c0a5bb580d7c54",
      "headRepository": "tls-attestation/use-cases-and-properties",
      "headRefName": "tireddy2-patch-1",
      "headRefOid": "31f180f3e328d2f8ce1bc7d0a72416248c02b47b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}